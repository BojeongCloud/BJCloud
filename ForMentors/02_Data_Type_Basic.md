# 2차시 상수와 기본 자료형

## C언어가 제공하는 기본 자료형의 이해

### 자료형 : 데이터를 표현하는 방법
변수는 데이터의 저장을 위해 할당된 메모리 공간에 붙여진 이름이라고 생각하면 좋다.  
메모리 할당 전에 “정수로 또는 실수로 저장할 것인지" 정해져야 한다 이것들을 자료형이라고 한다.

### 자료형의 종류와 데이터의 표현범위

범위를 정확히 기억할 필요는 없다. 참고용으로만 보자.

> 주로 사용하는 자료형은 `char`,`int`, `float`이다. 일단 이 자료형들만 알고 있어도 상관없다.

| 자료형      | 크기         | 값의 표현범위 |
| ---         | ---          | --- |
| **정수형**  |              |         |
| char        | 1바이트      | -128 이상 +127 이하 |
| short       | 2바이트      | -32,768 이상 +32,767이하 |
| int         | 4바이트      | -2,147,483,648이상 +2,147483,647이하 |
| long        | 4바이트      | -2,147,483,647이상 +2,147,483,647이하 |
| long long   | 8바이트      | -9,223,372,036,854,775,807이상 +9,223,372,036,854,775,807이하 |
| **실수형**  |              ||
| float       | 4바이트      | ±3.4 x 10-37이상 ±3.4 x 10+38이하 |
| double      | 8바이트      | ± 1.7 x 10-307이상 ±1.7 x 10+308이하 |
| long double | 8바이트 이상 | double 이상의 표현범위 |

정확한 범위는 아니다(C언어에서는 자료형 별 크기를 정확히 제한하고 있지 않는다.)
(C언어의 자료형은 기본적으로 “short와 int는 최소 2바이트, int는 short와 크기가 같거나 더 커야 한다”라고만 정해져있다)
왜 이렇게 자료형의 수가 많은가?
    1, 데이터의 표현방식이 다르므로(실수, 정수) 최소 두개 이상의 자료형이 필요
    2, 메모리 공간의 효율적인 사용을 위해 다양한 크기의 자료형이 필요
자료형의 크기는 sizeof ‘연산자’를 이용하면 알 수 있다

### 정수를 표현 및 처리하기 위한 일반적인 자료형의 선택

저장하고자 하는 값의 범위를 생각한 후, 상황에 맞게 선언한다. 다만 일반적으로 CPU가 처리하기에 가장 적합한 크기의 정수 자료형을 int로 정의한다. 일반적으로 int형 연산의 속도가 다른 자료형의 연산속도에 비해 동일하거나 더 빠르다. 이러한 이유 때문에 int보다 작은 자료형이라도 연산할 때는 int로 바뀌어 연산이 진행된다. (나중에 sizeof로 확인해보면 int의 크기인 4가 나온다) 따라서 속도보다 메모리를 아껴야 하는 경우는 제외하고 int 자료형을 많이 사용한다. 

### 실수를 표현 및 처리하기 위한 일반적인 자료형의 선택

어차피 실수의 자료형이 표현할 수 있는 값은 매우 넓다. 실수의 표현에는 오차가 존재할 수 밖에 없기 때문(±(1.m)X2e-127)에 값의 표현범위보다는 정밀도가 우선시된다. float는 소숫점 이하 6자리, double은 소숫점 이하 15자리, long double은 소숫점 이하 18자리까지는 오차가 발생하지 않는다. 실수는 보편적으로 double을 많이 사용한다. (float보다는 정밀도가 높고, long double보다는 메모리를 덜먹기 때문) (참고로 double형 데이터를 출력할 때는 %f, 입력받을 때는 %lf를 사용한다)

### unsigned - 부호가 없는 숫자
  
정수 자료형에 한해 unsigned 선언을 앞에 추가하면 0 이상의 값만 표현하는 자료형이 된다. signed라는 선언도 있으나 안 붙이는 것과 같기 때문에 대부분 생략한다. (int = signed int) 다만, char형은 예외일 수도 있다(char를 unsigned char 로 처리하는 컴파일러도 있기 때문)

## 문자의 표현방식과 문자를 위한 자료형

### 아스키(ASCII) 코드

숫자를 이용해 문자를 표현하려면 숫자를 문자에 연결(mapping)시키는 것이 유일한 방법이다. 그래서 C언어는 아스키(American Standard Code for Information Interchange)코드를 사용하여 문자를 표현한다. 아스키 코드는 알파벳과 특수문자를 합하여 128개의 문자로 이루어져 있다. ('윤성우의 열혈강의' 책 뒤에 가면 있다)

### 문자의 표현방법

    char ch1 = ‘A’;
단일 문자 표현에서는 작은 따옴표를 사용한다.

    char ch1 = 65;
문자 A의 아스키 코드 값이 65이므로 두 변수는 동일한 값을 가지고 있다. (컴파일할 때 이렇게 변환된다)

문자의 형태로 데이터를 출력할 때에는 서식문자 %c 를 사용한다. (숫자의 형태로 출력할 때는 %d 를 사용한다) int형 변수에도 저장은 가능하지만, 굳이 그렇게 할 필요가 없기 때문에 (int는 연산속도가 빠르지만, 아스키코드로 연산을 할 것이 아니기 때문) 대부분 char형 변수를 사용한다. (-128 ~ 127을 표현, 아스키코드는 0 ~ 127을 사용)

char형은 문자의 표현을 목적으로 정의된 자료형이기 때문에 ‘문자형’으로 분류하기도 하지만, 정수형이다(문자도 아스키코드라는 정수의 형태로 표현이 되고, char형 변수에 저장되는 것은 정수이기 때문)

### 자료형의 변환

#### 대입연산의 전달과정에서 발생하는 자동 형 변환 
대입 연산자의 왼편과 오른편에 존재하는 두 피연산자의 자료형이 일치하지 않으면, 왼쪽에 있는 피연산자를 기준으로 자동 형 변환이 일어난다.

* 정수를 실수로 형 변환하는 경우

    double num1 = 245; // int형 정수 245를 double형으로 자동 형 변환

245가 245.0으로 바뀌어 num1에 저장된다.

* 실수를 정수로 형 변환하는 경우
    int num2 = 3.1415; // double형 실수 3.1415를 int형으로 자동 형 변환
    
3.1415가 3으로 바뀌어(소숫점 이하 표현 불가능) num2에 저장된다.

* 바이트 크기가 큰 정수를 바이트 크기가 작은 정수로 형 변환하는 경우
    int num3 = 129;
    char ch = num3; // int형 변수 num3에 저장된 값이 char형으로 자동 형 변환

char는 -128 ~ +127(00000000)
129의 비트 열은 10000001
10000001을 char로 넣으면 -127이 된다.
이렇게 바이트의 손실로 인해 부호가 바뀌어버리는 경우도 있으니 주의하자.

> 데이터의 표현범위가 보다 넓은 자료형으로의 형 변환은, 그 과정에서의 데이터의 손실이 발생하지 않지만, 
> 데이터의 표현범위가 좁은 자료형으로의 형 변환은, 그 과정에서의 데이터의 손실이 발생할 수 있다

#### 정수의 승격(Integral Promotion)에 의한 자동 형 변환

일반적으로 CPU가 처리하기에 가장 적합한 크기의 정수 자료형을 int로 정의한다. int형 연산의 속도가 다른 자료형의 연산속도에 비해 동일하거나 더 빠르기 때문에 int 보다 작은 크기의 정수형 데이터는 int형 데이터로 형 변환이 되어서 연산이 진행된다. (사실 현재 컴퓨터는 CPU의 성능과 구조가 많이 개선되어 연산속도는 거의 동일하다. 하지만 세상에는 많은 종류의 CPU가 있고, 새로운 CPU의 등장도 고려해야 하기 때문에 여전히 정수의 승격은 의미를 가진다)

    short num1 = 15, num2 = 25;
    short num3 = num1 + num2; 

num1 과 num2 가 int형으로 형변환 후 덧셈연산이 진행되고, short에 저장하기 위해 다시 형변환된다. 이러한 형 변환을 ‘정수의 승격(Integral Promotion)’이라고 한다.

#### 피연산자의 자료형 불일치로 발생하는 자동 형변환
기본적으로 정수와 실수는 표현방직이 다르므로 연산이 불가능하다. 연산을 하려면 정수를 실수로 형 변환하거나 실수를 정수로 형변환하여 연산해야 한다. 실수를 정수로 변환하는 것보다 정수를 실수로 변환하는 것이 데이터의 손실(오차)가 적다

(뭔가 더 있던 것 같다)

이 순서로 형 변환된다.(데이터의 손실을 최소화하는 방향으로 진행되기 때문에 실수의 자료형이 무조건 앞선다.)


#### 강제로 일으키는 명시적 형변환 ~~(수정바람)~~
    int num1 = 3, num2 = 4;
    double divresult;
    divresult = num1 / num2; // 이경우 num1(정수) / num2(정수)는 같은 자료형인 0이 나오고 나머지가 3이 된다
    divresult = (double)num1 / num2; // 이 경우 형 변환 연산자
    
((double))에 의해 num1은 3.0 num2는 4.0인 실수로 형변환되어 연산하므로 0.75가 나온다. 이때 (double)을 형 변환 연산자라고 한다.


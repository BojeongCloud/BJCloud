3차시(상수와 기본 자료형 ~ printf함수와 scanf함수)

05. 상수와 기본 자료형

1) C언어가 제공하는 기본 자료형의 이해

자료형 : 데이터를 표현하는 방법
변수는 데이터의 저장을 위해 할당된 메모리 공간에 붙여진 이름이라고 설명하였는데, 메모리 할당 전에 “정수로 저장 or 실수로 저장”이 정해져야 한다
“정수 or 실수”가 정해지면 메모리 공간 할당(byte)도 해야됨
이것들을 자료형이라고 한다

1. 자료형의 종류와 데이터의 표현범위
  
자료형
크기
값의 표현범위


정수형
char
1바이트(28)
-128 이상 +127 이하

short
2바이트
-32,768 이상 +32,767이하

int
4바이트
-2,147,483,648이상 +2,147483,647이하

long
4바이트
-2,147,483,647이상 +2,147,483,647이하

long long
8바이트
-9,223,372,036,854,775,807이상 +9,223,372,036,854,775,807이하

실수형
float
4바이트
±3.4 x 10-37이상 ±3.4 x 10+38이하

double
8바이트
± 1.7 x 10-307이상 ±1.7 x 10+308이하

long double
8바이트 이상
double 이상의 표현범위
정확한 범위는 아니다(C언어에서는 자료형 별 크기를 정확히 제한하고 있지 않는다.)
(C언어의 자료형은 기본적으로 “short와 int는 최소 2바이트, int는 short와 크기가 같거나 더 커야 한다”라고만 정해져있다)
왜 이렇게 자료형의 수가 많은가?
    1, 데이터의 표현방식이 다르므로(실수, 정수) 최소 두개 이상의 자료형이 필요
    2, 메모리 공간의 효율적인 사용을 위해 다양한 크기의 자료형이 필요
자료형의 크기는 sizeof ‘연산자’를 이용하면 알 수 있다

2. 정수를 표현 및 처리하기 위한 일반적인 자료형의 선택

저장하고자 하는 값의 범위를 생각한 후, 상황에 맞게 선언한다.
다만 일반적으로 CPU가 처리하기에 가장 적합한 크기의 정수 자료형을 int로 정의해서, int형 연산의 속도가 다른 자료형의 연산속도에 비해 동일하거나 더 빠르다
이러한 이유 때문에 int보다 작은 자료형은 연산할 때 int로 바꾸어 연산이 진행된다.(나중에 sizeof로 확인해보면 int의 크기인 4가 나온다)
이러한 이유 때문에 보편적으로 int를 많이 사용한다(속도보다 메모리를 아껴야 하는 경우는 제외)
3. 실수를 표현 및 처리하기 위한 일반적인 자료형의 선택

어차피 실수의 자료형이 표현할 수 있는 값은 매우 넓다
      실수의 표현에는 오차가 존재할 수 밖에 없기 때문(±(1.m)X2e-127)에 값의 표현범위보다는 정밀도가 우선시된다.
      float는 소숫점 이하 6자리, double은 소숫점 이하 15자리, long double은 소숫점 이하 18자리까지는 오차가 발생하지 않는다.
      실수는 보편적으로 double을 많이 사용함(float보다는 정밀도가 높고, long double보다는 메모리를 덜먹기 때문)
      (참고로 double형 데이터를 출력할 때는 %f, 입력받을 때는 %lf를 사용한다)

4. unsigned
  
정수 자료형에 한해 unsigned 선언을 앞에 추가하면 0 이상의 값만 표현하는 자료형이 된다.
signed라는 선언도 있으나 안 붙이는 것과 같기 때문에 대부분 생략한다(int = signed int)
다만, char형은 예외일 수도 있다(char를 unsigned char 로 처리하는 컴파일러도 있기 때문)

1) 문자의 표현방식과 문자를 위한 자료형

    1. 아스키(ASCII) 코드

숫자를 이용해 문자를 표현하려면 숫자를 문자에 연결(mapping)시키는 것이 유일한 방법이다
그래서 C언어는 아스키(American Standard Code for Information Interchange)코드를 사용하여 문자를 표현한다.
아스키 코드는 알파벳과 특수문자를 합하여 128개의 문자로 이루어져 있다(C언어 책 뒤에 가면 있다)

    2. 문자의 표현방법

      char ch1 = ‘A’;
      프로그램상의 문자 표현에서는 작은 따옴표를 사용한다.

      char ch1 = 65;
      문자 A의 아스키 코드 값이 65이므로 두 변수는 동일한 값을 가지고 있다.(컴파일할 때 이렇게 변환되어 컴파일된다)

      문자의 현태로 데이터를 출력할 때에는 서식문자 %c를 사용한다(숫자의 형태로도(%d) 출력 가능하다)
      int형 변수에도 저장은 가능하지만, 굳이 그렇게 할 필요가 없기 때문에(int는 연산속도가 빠르지만, 아스키코드로 연산을 할것이 아니기 때문) 대부분 char형 변수를 사용한다(-128 ~ 127을 표현, 아스키코드는 0~127)(메모리 절약)

      char형은 문자의 표현을 목적으로 정의된 자료형이기 때문에 ‘문자형’으로 분류하기도 하지만, 정수형이다(문자도 아스키코드라는 정수의 형태로 표현이 되고, char형 변수에 저장되는 것은 정수이기 때문)


2) 상수에 대한 이해
상수 = 변경 불가능한 데이터

1. 이름을 지니지 않는 리터럴(Literal) 상수
  int num = 30 + 40 // 30과 40은 상수이다.
  덧셈이 우선 진행되고 그 결과로 얻어진 값으로 num을 초기화하게 된다
  30 + 40의 연산을 CPU가 하기 위해서는 두 정수가 모두 메모리상에 존재해야 한다.
  30과 40이 메모리 공간에 상수의 형태로 저장되고, 두 상수를 기반으로 덧셈이 저장된 후, 덧셈의 결과가 num에 저장된다.
  상수에게 할당된 메모리 공간에 이름이 없는 것을 볼 수 있는데, 이렇게 이름이 없는 상수를 리터럴(Literal)상수 또는 리터럴이라고 한다.

2. 리터럴 상수의 자료형
  상수도 자료형이 존재한다, 그러므로 상수도 어떠한 자료형으로 저장할지를 결정해야 한다.
  int형으로 표현 가능한 정수형 상수는 int형으로, double형으로 표현 가능한 실수형 상수는 double형으로 표현하기로 약속(정의)되어 있다.(대입 연산자의 자료형에 따라서 상수의 자료형이 결정되는 것은 아니다)
  문자형 상수인 경우에도 ‘A’ = 65이니 int형으로 표현된다.

3. 접미사를 이용한 다양한 상수의 표현
  int와 double을 제외한 다른 자료형을 사용해 상수를 표현하려면 해당 자료형을 의미하는 접미사를 붙여주면 된다.(접미사를 붙이지 않아도 되지만 데이터가 잘려나갈 수도 있다는 경고 메시지가 뜬다)
자료형
접미사
사용의 예
정수
unsigned int
U
unsigned int n = 1025U

long
L
long n = 2467L

unsigned long
UL
unsigned long n = 3456UL

long long
LL
long long n = 5768LL

unsigned long long
ULL
unsigned long long = 8979ULL
실수
float
F
float f = 3.15F

long double
L
long double f = 5.789L
 대부분 기본적인 자료형인 int와 double은 접미사를 붙이지 않고 나머지는 첫번째 알파벳을 붙인다(대소문자 구분X)

      4. 이름을 지니는 심볼릭(Symbolic) 상수 : const 상수
        심볼릭 상수를 표현하는 방법에는 const 키워드를 사용하는것과 매크로를 사용하는 것 두가지가 있다
        const 키워드를 이용해서 상수를 만들려면 변수 선언할 때 앞에 const 선언만 추가하면 된다.
        const int MAX = 100;  // 값의 변경 불가
        const int MAX; // 이 이상 값의 변경이 불가능
        MAX = 100; // 컴파일 에러
        다만 이렇게 선언과 초기화를 분리시킬수 없다.
        상수의 이름은 모두 대문자로 표시하고, 둘 이상의 단어로 연결할때는 MY_AGE와 같이 언더바를 이용애서 두 단어를 구분하는 것이 관례이다(변수와 상수의 구분을 용이하게 하기 위함)
  4) 자료형의 변환
      1. 대입연산의 전달과정에서 발생하는 자동 형 변환
        대입 연산자의 왼편과 오른편에 존재하는 두 피연산자의 자료형이 일치하지 않으면, 왼쪽에 있는 피연산자를 기준으로 자동 형 변환이 일어난다.
        ▶정수를 실수로 형 변환하는 경우
        double num1 = 245; // int형 정수 245를 double형으로 자동 형 변환
        245가 245.0으로 바뀌어 num1에 저장된다.
        ▶실수를 정수로 형 변환하는 경우
        int num2 = 3.1415; // double형 실수 3.1415를 int형으로 자동 형 변환
        3.1415가 3으로 바뀌어(소숫점 이하 표현 불가능) num2에 저장된다.
        ▶바이트 크기가 큰 정수를 바이트 크기가 작은 정수로 형 변환하는 경우
        int num3 = 129;
        char ch = num3; // int형 변수 num3에 저장된 값이 char형으로 자동 형 변환
        char는 -128 ~ +127(00000000)
        129의 비트 열은 10000001
        10000001을 char로 넣으면 -127이 된다.
        이렇게 바이트의 손실로 인해 부호가 바뀌어버리는 경우도 있으니 주의하자
        『데이터의 표현범위가 보다 넓은 자료형으로의 형 변환은, 그 과정에서의 데이터의 손실이 발생하지 않지만, 데이터의 표현범위가 좁은 자료형으로의 형 변환은, 그 과정에서의 데이터의 손실이 발생할 수 있다.』

      2. 정수의 승격(Integral Promotion)에 의한 자동 형 변환
        일반적으로 CPU가 처리하기에 가장 적합한 크기의 정수 자료형을 int로 정의해서, int형 연산의 속도가 다른 자료형의 연산속도에 비해 동일하거나 더 빠르기 때문에 int 보다 작은 크기의 정수형 데이터는 int형 데이터로 형 변환이 되어서 연산이 진행된다.(사실 현재 컴퓨터는 CPU의 성능과 구조가 많이 개선되어 연산속도는 거의 동일하다. 하지만 세상에는 많은 종류의 CPU가 있고, 새로운 CPU의 등장도 고려해야 하기 때문에 여전히 정수의 승격은 의미를 가진다)
         short num1 = 15, num2 = 25;
         short num3 = num1 + num2; // num1 과 num2가 int형으로 형변환(후 short에 저장하기 위해 다시 형변환)
         이러한 형 변환을 ‘정수의 승격(Integral Promotion)’이라고 한다.

      3. 피연산자의 자료형 불일치로 발생하는 자동 형 변환
         기본적으로 정수와 실수는 표현방직이 다르므로 연산이 불가능하다. 
         연산을 하려면 정수를 실수로 형 변환하거나 실수를 정수로 형 변환하여 연산해야 한다 << 자동 형 변환
         실수를 정수로 변환하는 것보다 정수를 실수로 변환하는 것이 데이터의 손실(오차)가 적다

     

         이 순서로 형 변환된다.(데이터의 손실을 최소화하는 방향으로 진행되기 때문에 실수의 자료형이 무조건 앞선다.)
      4, 강제로 일으키는 명시적 형 변환
        int num1 = 3, num2 = 4;
        double divresult;
        divresult = num1 / num2; // 이경우 num1(정수) / num2(정수)는 같은 자료형인 0이 나오고 나머지가 3이 된다
        divresult = (double)num1 / num2; // 이 경우 형 변환 연산자((double))에 의해 num1은 3.0 num2는 4.0인 실수로 형변환되어 연산하므로 0.75가 나온다.
        이때 (double)을 형 변환 연산자라고 한다.

06. printf 함수와 scanf함수

1) printf 함수
1. printf 함수는 문자열을 출력하는 함수이다.
  C언어는 큰따옴표(“”)를 사용해서 문자열을 표현한다.

2. 특수문자의 출력이 필요한 이유
  특수문자는 독립된 문자상수로 존재할 수 있다.(char ch = ‘\n’)
  출력하고자 하는 문자열에 큰따옴표가 있는 경우, 문자열을 표현하는 큰따옴표와 중첩되어 큰따옴표에 있는 내용은 출력되지 않는다.
  이것을 막고자 특수문자 \”가 탄생(큰따옴표의 출력)
 후에 다른것도 만들어졌다.
특수문자
의미
특수문자
의미
특수문자
의미
\a
경고음
\r
캐리지 리턴
\”
큰따옴표 출력
\b
백스페이스
\t
수평 탭
\?
물음표 출력
\f
폼 피드
\
수직 탭
\\
역슬래쉬 출력
\n
개행
\’
작은 따옴표 출력


  \f와 \v는 모니터 출력이 아니라 프린터 출력을 위해 정의된 특수문자이기 때문에 모니터의 출력에 사용을 하면, 이상한 문자가 출력된다.

3. printf 함수의 서식지정
  printf의 f는 formatted(서식이 지정된)을 의미한다. >> 출력양식을 만들어진 상태에서 출력한다
  ex) “000는 %d며 %X이다”라는 서식을 만들어놓고 변수를 집어넣은다음 출력한다.(%X = 16진수, 대문자 출력. %x = 16진수, 소문자 출력)
  







4. 서식문자의 종류와 그 의미
  
서식문자
출력 대상(자료형)
출력 형태
%d
char, short, int 
부호 있는 10진수 정수
%ld
long
부호 있는 10진수 정수
%lld
long long
부호 있는 10진수 정수
%u
unsigned int
부호 없는 10진수 정수
%o
unsigned int
부호 없는 8진수 정수
%x, %X
unsigned int
부호 없는 16진수 정수
%f
float, double
10진수 방식의 부동소수점 실수
%Lf
long double
10진수 방식의 부동소수점 실수
%e, %E
float, double
e 또는 E 방식의 부동소수점 실수
%g, %G
float, double
값에 따라 %f와 %e 사이에서 선택
%c
char, short, int
값에 대응하는 문자
%s
char *
문자열
%p
void *
포인터의 주소값
  8진수를 8진수답게(0123), 16진수를 16진수답게(0x123) 출력하고 싶다면 % 다음에 #을 넣어주면 된다.
  %e나 %E로 출력했을 시에는 m.n X 10k가 m.ne+k로 나온다
  %g는 소수점 이하의 자리수가 늘어나면 e로 표기한다
  %s로는 문자’열’을 출력할 수 있다.
  % 다음에 ±k를 집어넣어 폭 확보와 오른쪽/왼쪽 정렬을 할 수 있다.

   2) scanf 함수
        printf에서 사용되던 서식문자가 ‘출력’ 대신 ‘입력’으로 사용된다.
        다만 double은 %lf, long double은 %Lf을 사용한다.(float는 %f로 동일)
        실수의 입력과정에서 e표기법을 사용해도 무방하다.
        %s는 문자’열’을 입력하는데 사용된다.
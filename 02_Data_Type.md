# 2차시 상수와 기본 자료형

## C언어가 제공하는 기본 자료형의 이해

### 자료형 : 데이터를 표현하는 방법
변수는 데이터의 저장을 위해 할당된 메모리 공간에 붙여진 이름이라고 생각하면 좋다. 메모리 할당 전에 “정수로 또는 실수로 저장할 것인지" 정해져야 한다 이것들을 자료형이라고 한다.

### 자료형의 종류와 데이터의 표현범위

| 자료형 | 크기 | 값의 표현범위 |
| --- | --- | --- |
|**정수형** |||
| char | 1 바이트 | -128 이상 +127 이하 |
| short | 2바이트 | -32,768 이상 +32,767이하 |
| int | 4바이트 | -2,147,483,648이상 +2,147483,647이하 |
| long | 4바이트 | -2,147,483,647이상 +2,147,483,647이하 |
| long long | 8바이트 | -9,223,372,036,854,775,807이상 +9,223,372,036,854,775,807이하 |
|**실수형**|||
| float | 4바이트 | ±3.4 x 10-37이상 ±3.4 x 10+38이하 |
| double | 8바이트 | ± 1.7 x 10-307이상 ±1.7 x 10+308이하 |
|long double | 8바이트 이상 | double 이상의 표현범위 |

정확한 범위는 아니다(C언어에서는 자료형 별 크기를 정확히 제한하고 있지 않는다.)
(C언어의 자료형은 기본적으로 “short와 int는 최소 2바이트, int는 short와 크기가 같거나 더 커야 한다”라고만 정해져있다)
왜 이렇게 자료형의 수가 많은가?
    1, 데이터의 표현방식이 다르므로(실수, 정수) 최소 두개 이상의 자료형이 필요
    2, 메모리 공간의 효율적인 사용을 위해 다양한 크기의 자료형이 필요
자료형의 크기는 sizeof ‘연산자’를 이용하면 알 수 있다

### 정수를 표현 및 처리하기 위한 일반적인 자료형의 선택

저장하고자 하는 값의 범위를 생각한 후, 상황에 맞게 선언한다. 다만 일반적으로 CPU가 처리하기에 가장 적합한 크기의 정수 자료형을 int로 정의한다. 일반적으로 int형 연산의 속도가 다른 자료형의 연산속도에 비해 동일하거나 더 빠르다. 이러한 이유 때문에 int보다 작은 자료형이라도 연산할 때는 int로 바뀌어 연산이 진행된다. (나중에 sizeof로 확인해보면 int의 크기인 4가 나온다) 따라서 속도보다 메모리를 아껴야 하는 경우는 제외하고 int 자료형을 많이 사용한다. 

### 실수를 표현 및 처리하기 위한 일반적인 자료형의 선택

어차피 실수의 자료형이 표현할 수 있는 값은 매우 넓다. 실수의 표현에는 오차가 존재할 수 밖에 없기 때문(±(1.m)X2e-127)에 값의 표현범위보다는 정밀도가 우선시된다. float는 소숫점 이하 6자리, double은 소숫점 이하 15자리, long double은 소숫점 이하 18자리까지는 오차가 발생하지 않는다. 실수는 보편적으로 double을 많이 사용한다. (float보다는 정밀도가 높고, long double보다는 메모리를 덜먹기 때문) (참고로 double형 데이터를 출력할 때는 %f, 입력받을 때는 %lf를 사용한다)

### unsigned - 부호가 없는 숫자
  
정수 자료형에 한해 unsigned 선언을 앞에 추가하면 0 이상의 값만 표현하는 자료형이 된다. signed라는 선언도 있으나 안 붙이는 것과 같기 때문에 대부분 생략한다. (int = signed int) 다만, char형은 예외일 수도 있다(char를 unsigned char 로 처리하는 컴파일러도 있기 때문)

## 문자의 표현방식과 문자를 위한 자료형

### 아스키(ASCII) 코드

숫자를 이용해 문자를 표현하려면 숫자를 문자에 연결(mapping)시키는 것이 유일한 방법이다. 그래서 C언어는 아스키(American Standard Code for Information Interchange)코드를 사용하여 문자를 표현한다. 아스키 코드는 알파벳과 특수문자를 합하여 128개의 문자로 이루어져 있다. ('윤성우의 열혈강의' 책 뒤에 가면 있다)

### 문자의 표현방법

    char ch1 = ‘A’;
단일 문자 표현에서는 작은 따옴표를 사용한다.

    char ch1 = 65;
문자 A의 아스키 코드 값이 65이므로 두 변수는 동일한 값을 가지고 있다. (컴파일할 때 이렇게 변환된다)

문자의 형태로 데이터를 출력할 때에는 서식문자 %c 를 사용한다. (숫자의 형태로 출력할 때는 %d 를 사용한다) int형 변수에도 저장은 가능하지만, 굳이 그렇게 할 필요가 없기 때문에 (int는 연산속도가 빠르지만, 아스키코드로 연산을 할 것이 아니기 때문) 대부분 char형 변수를 사용한다. (-128 ~ 127을 표현, 아스키코드는 0 ~ 127을 사용)

char형은 문자의 표현을 목적으로 정의된 자료형이기 때문에 ‘문자형’으로 분류하기도 하지만, 정수형이다(문자도 아스키코드라는 정수의 형태로 표현이 되고, char형 변수에 저장되는 것은 정수이기 때문)

### 상수에 대한 이해 (상수 = 변경 불가능한 데이터)

#### 이름을 지니지 않는 리터럴(Literal) 상수
    int num = 30 + 40; // 30과 40은 상수
    
덧셈이 우선 진행되고 그 결과로 얻어진 값으로 num을 초기화하게 된다. 30 + 40의 연산을 CPU가 하기 위해서는 두 정수가 모두 메모리상에 존재해야 한다. 30과 40이 메모리 공간에 상수의 형태로 저장되고, 두 상수를 기반으로 덧셈이 저장된 후, 덧셈의 결과가 num에 저장된다. 상수에게 할당된 메모리 공간에 이름이 없는 것을 볼 수 있는데, 이렇게 이름이 없는 상수를 리터럴(Literal)상수 또는 리터럴이라고 한다.

#### 리터럴 상수의 자료형
상수도 자료형이 존재한다, 그러므로 상수도 어떠한 자료형으로 저장할지를 결정해야 한다. int형으로 표현 가능한 정수형 상수는 int형으로, double형으로 표현 가능한 실수형 상수는 double형으로 표현하기로 약속(정의)되어 있다. (대입 연산자의 자료형에 따라서 상수의 자료형이 결정되는 것은 아니다) 문자형 상수인 경우에도 ‘A’ = 65이니 int형으로 표현된다.

#### 접미사를 이용한 다양한 상수의 표현
int와 double을 제외한 다른 자료형을 사용해 상수를 표현하려면 해당 자료형을 의미하는 접미사를 붙여주면 된다. (접미사를 붙이지 않아도 되지만 데이터가 잘려나갈 수도 있다는 경고 메시지가 뜬다)

| 자료형 | 접미사 | 사용의 예 |
| --- | --- | --- |
| **정수** |||
| unsigned int | U | unsigned int n = 1025U |
| long | L | long n = 2467L |
| unsigned long | UL | unsigned long n = 3456UL |
| long long | LL | long long n = 5768LL |
| unsigned long long | ULL | unsigned long long = 8979ULL |
|**실수** |||
| float | F | float f = 3.15F |
| long double | L | long double f = 5.789L |

대부분 기본적인 자료형인 int와 double은 접미사를 붙이지 않고 나머지는 첫번째 알파벳을 붙인다. (대소문자 구분X)

#### 이름을 지니는 심볼릭(Symbolic) 상수 : const 상수
 
심볼릭 상수를 표현하는 방법에는 const 키워드를 사용하는것과 매크로를 사용하는 것 두가지가 있다. const 키워드를 이용해서 상수를 만들려면 변수 선언할 때 앞에 const 선언만 추가하면 된다.

    const int MAX = 100; 
    MAX = 110; // 컴파일 에러

다만 이렇게 선언과 초기화를 분리시킬수 없다. 상수의 이름은 모두 대문자로 표시하고, 둘 이상의 단어로 연결할때는 MY_AGE와 같이 언더바(_)를 이용애서 두 단어를 구분하는 것이 관례이다. (변수와 상수의 구분을 용이하게 하기 위함이다)

### 자료형의 변환

#### 대입연산의 전달과정에서 발생하는 자동 형 변환 
대입 연산자의 왼편과 오른편에 존재하는 두 피연산자의 자료형이 일치하지 않으면, 왼쪽에 있는 피연산자를 기준으로 자동 형 변환이 일어난다.

* 정수를 실수로 형 변환하는 경우

    double num1 = 245; // int형 정수 245를 double형으로 자동 형 변환

245가 245.0으로 바뀌어 num1에 저장된다.

* 실수를 정수로 형 변환하는 경우
    int num2 = 3.1415; // double형 실수 3.1415를 int형으로 자동 형 변환
        3.1415가 3으로 바뀌어(소숫점 이하 표현 불가능) num2에 저장된다.

* 바이트 크기가 큰 정수를 바이트 크기가 작은 정수로 형 변환하는 경우
        int num3 = 129;
        char ch = num3; // int형 변수 num3에 저장된 값이 char형으로 자동 형 변환
        char는 -128 ~ +127(00000000)
        129의 비트 열은 10000001
        10000001을 char로 넣으면 -127이 된다.
        이렇게 바이트의 손실로 인해 부호가 바뀌어버리는 경우도 있으니 주의하자
        『데이터의 표현범위가 보다 넓은 자료형으로의 형 변환은, 그 과정에서의 데이터의 손실이 발생하지 않지만, 데이터의 표현범위가 좁은 자료형으로의 형 변환은, 그 과정에서의 데이터의 손실이 발생할 수 있다.』

#### 정수의 승격(Integral Promotion)에 의한 자동 형 변환

일반적으로 CPU가 처리하기에 가장 적합한 크기의 정수 자료형을 int로 정의해서, int형 연산의 속도가 다른 자료형의 연산속도에 비해 동일하거나 더 빠르기 때문에 int 보다 작은 크기의 정수형 데이터는 int형 데이터로 형 변환이 되어서 연산이 진행된다. (사실 현재 컴퓨터는 CPU의 성능과 구조가 많이 개선되어 연산속도는 거의 동일하다. 하지만 세상에는 많은 종류의 CPU가 있고, 새로운 CPU의 등장도 고려해야 하기 때문에 여전히 정수의 승격은 의미를 가진다)

    short num1 = 15, num2 = 25;
    short num3 = num1 + num2; 

num1 과 num2 가 int형으로 형변환 후 덧셈연산이 진행되고, short에 저장하기 위해 다시 형변환된다. 이러한 형 변환을 ‘정수의 승격(Integral Promotion)’이라고 한다.

#### 피연산자의 자료형 불일치로 발생하는 자동 형변환
기본적으로 정수와 실수는 표현방직이 다르므로 연산이 불가능하다. 연산을 하려면 정수를 실수로 형 변환하거나 실수를 정수로 형변환하여 연산해야 한다. 실수를 정수로 변환하는 것보다 정수를 실수로 변환하는 것이 데이터의 손실(오차)가 적다

(뭔가 더 있던 것 같다)

이 순서로 형 변환된다.(데이터의 손실을 최소화하는 방향으로 진행되기 때문에 실수의 자료형이 무조건 앞선다.)


#### 강제로 일으키는 명시적 형변환
    int num1 = 3, num2 = 4;
    double divresult;
    divresult = num1 / num2; // 이경우 num1(정수) / num2(정수)는 같은 자료형인 0이 나오고 나머지가 3이 된다
    divresult = (double)num1 / num2; // 이 경우 형 변환 연산자
    
((double))에 의해 num1은 3.0 num2는 4.0인 실수로 형변환되어 연산하므로 0.75가 나온다. 이때 (double)을 형 변환 연산자라고 한다.


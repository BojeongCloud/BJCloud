# C언어의 핵심! 함수

**알립니다!**  
이 자료는 멘토링의 방향을 설정하여 멘토들을 돕기위한 목적으로 만들어졌음을 밝힙니다.  
이 자료를 이용하되, **윤성우의 열혈강의** 교재를 정독하고 멘토링을 준비하시기 바랍니다.

* 윤성우의 열혈강의 p.212 의 SimpleAddFunc.c 작성해보기

## 함수의 기본 형태
    int main(int a, int b) { 
        return 0;
    }

* int 는 **반환값의 데이터형**
* main 은 **함수의 이름**
* (int a, int b) 소괄호는 **전달받는 인수들**
* { return 0; } 중괄호는 **함수의 정의**

### 함수를 만드는 이유
main 함수 안에서만 모든 프로그램을 짜려고 하면 중복구문으로 인해 길이가 엄청나게 길어진다.  
중복구문이 붙어있는 경우에는 반복문으로 해결할 수 있지만 붙어있지 않는 경우에는 얄짤없이 적어야 한다.  
중복되는 구문을 함수로 떼어놓아서 필요할 때 불러와 사용해서 전체 길이를 줄인다.

### 함수의 입력과 출력

대표적으로 우리가 사용하는 printf() 함수도 반환을 한다.  
'\n' 문자를 포함한 모니터에 출력한 문자열의 길이를 반환한다.  
한글은 한 글자당 문자열 2개로 계산한다. (한글은 2바이트로 표현하기 때문)

### 함수의 4가지 형태

1. 전달인자 O, 반환인자 O
  
        int main(int a, int b) { return 0; }

2. 전달인자 O, 반환값 X(출력)

        void main(int a, int b) { return; }

3. 전달인자 X, 반환값 O(입력)

        int main(int a, int b) { return 0; }

4. 전달인자 X, 반환값 X

        void main(void) { return; }

### return이 갖는 두 가지 의미
return 구문은 **함수를 빠져나가는 기능**과 **값을 반환하는 기능**을 가지고 있다.  
break 구문은 반복문 또는 조건문을 빠져나갈 때 사용하므로 혼동하지 말자.

    int main() {
        int a = 1;
        int b = 2;
        int c = 7;        

        return c;

        c = a + b; // 이 명령어는 실행되지 않고 함수가 끝난다
    }

위 main 함수가 반환하는 값은 7이다.

### 함수의 정의와 그에 따른 선언
main 함수가 다른 함수를 호출하기 위해서는, 그 함수의 선언이 다음과 같이 main 함수 위에 있어야 한다.

    int sum(int a, int b) {
        return a + b;
    }
    
    int main() {
        int num1 = 3;
        int num2 = 4;
        int result;

        result = sum(num1, num2);
    }

하지만 함수의 선언과 정의를 분리함으로서 다음과 같이 쓸 수 있다.

    int sum(int a, int b);  // 함수의 선언
    
    int main() {
        int num1 = 3;
        int num2 = 4;
        int result;

        result = sum(num1, num2);
    }

    int sum(int a, int b) { // 함수의 정의
        return a + b;
    }

### 다양한 종류의 함수 정의하기

return 구문이 여러 개 있는 함수도 정의할 수 있으며 함수 안에서 또다른 함수를 불러오는것도 가능하다.

* 윤성우의 열혈강의 p.219의 AbsoCompare.c 작성해보기

## 변수의 존재 기간과 존재 범위
변수는 선언되는 위치에 따라서 크게 ‘전역변수’와 ‘지역변수’로 나뉜다.  
메모리 상에 존재하는 기간, 변수에 접근할 수 있는 범위에서 차이를 보인다.

### 지역변수
선언되는 중괄호 안에서만 유효하다. 이름이 같아도 다른 중괄호에서 선언되면 다른 변수로 간주한다.  
중괄호 안에서 선언되는 변수이기 때문에 반복문이나 조건문에서도 선언할 수 있다.  
단, 이름이 같을 경우, 바깥에서 선언된 변수는 가장 안쪽의 중괄호에서 선언된 같은 이름의 변수로 가려진다.

    int main() {
        int a = 0; 
        int b = 3;
        int i;
        
        for (i = 0; i < 3; i++) {
            int a = 5;
            b += a;
        }
        
        return b;
    }

b의 값은 18이다.

* 윤성우의 열혈강의 p.228의 LocalValHideVal.c 작성해보기

### 전역변수
중괄호 밖에 선언되며 같은 파일 안에서 정의된 모든 함수에서 접근할 수 있다.  
프로그램의 시작과 동시에 선언되며 종료시까지 존재한다. 초기화 값을 명시하지 않으면 0으로 자동 초기화된다.

>**전역변수와 동일한 이름의 지역변수가 선언된다면?**
>
>반복문이나 조건문에서의 지역변수와 같이 전역변수는 가려지고, 지역변수로 접근된다.  
>다만 별로 좋지 않은 습관이며 전역변수와 지역변수의 이름은 다르게 정하는 것이 좋다. 

애초에 전역변수를 많이 쓰지 않는 것이 좋은데, 전역변수를 많이 쓰게 되면 프로그램은 복잡해지고,  
좋은 구조의 프로그램과는 거리가 멀어진다, 고로 전역변수의 선언은 신중히 해야한다. - 윤성우의 열혈강의 p.233

    int a = 7

    int global_sum(int b) {
        return a + b;
    }

    int local_sum(int a, int b) {
        return a + b;
    }

    int main() {
        int c = global_sum(5);
        int d = local_sum(3, 4);
    }
	
* 윤성우의 열혈강의 p.231의 LocalValHideGlobalVal.c 작성해보기

### static 변수

프로그램이 실행된다는 것은 프로그램의 명령어들이 메인메모리에 저장되고 그 명령어들이 중앙처리장치(CPU)에 의해서 처리된다는 것을 의미한다. 메인메모리는 용도와 목적에 따라 크게 다음 4가지로 구분할 수 있다: 스텍(stack), 힙(heap), 코드(code), 데이터(data). 변수를 저장하는 곳은 주로 스택 그리고 힙 영역이다. 하지만 데이터 영역에도 저장되기도 하는데, 이 변수들이 바로 static 변수이다. 

> 데이터 영역에는 전역변수와 static으로 선언되는 static 변수가 할당된다.  
> 즉, 이 여역에 할당되는 변수들은 프로그램의 시작과 동시에 메모리 공간에 할당되어  
> 프로그램 종료시까지 남아있게 된다는 특징이 있다.

그래서 사실은 데이터라는 이름 대신에 static 영역이라는 이름을 사용하기도 한다.

#### static 지역변수
프로그램이 시작할 때 메모리 공간에 할당되지만, 선언된 함수 안에서만 접근이 가능하다.

#### static 전역변수
프로그램이 시작할 때 메모리 공간에 할당되지만, 모든 곳에서 접근이 가능하다.

### register 지역변수
중앙처리장치(CPU)에는 레지스터라는 매우 작고 빠른 저장공간이 존재한다.  
레지스터 변수는 프로그램 안에서 빈번하게 사용되고 매우 빠른 연산을 수행해야 할 때 사용한다.  

    int SoSimple() {
        register int num = 3;
		...
	}

위와 같이 변수를 선언하면 레지스터에 변수를 저장딜 확률이 높아진다.  
실감나는 설명을 위해서는 윤성우의 열혈강의 p.236의 설명을 읽어보는 것을 추천

## 재귀함수에 대한 이해

### 재귀함수의 기본적인 이해

어떤 함수가 자기 자신을 호춣한다면 어떻게 될까?

    void CallMe(int number) {
        if(number < 1) {
            return;
		} else {
            return CallMe(number - 1);
		}
    }

위와 같이 함수를 작성하는 것이 무슨 필요가 있을까 생각이 들 수 있을 것이다.  
하지만 위와 같이 재귀함수를 사용하면 _때로는_ 코드의 길이를 상당히 줄이는데 공헌하기도 한다.  
하지만 메모리 상에서 함수를 여러번 호출하게 되면 Stack Overflow가 발생해서 에러가 생길 수 있다.  
Stack Overflow를 방지하기 위해서는 재귀함수 대신에 반복문(iteration)을 사용한다.

### 재귀함수 사용법
팩토리얼이나 피보나치 수열 같은 수식을 그대로 옮길 수 있다.

* 윤성우의 열혈강의 p.243의 RecursiveFactorial.c 작성해보기

## Homework
* 윤성우의 열혈강의 p.250의 도전 8
